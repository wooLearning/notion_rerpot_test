<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>INT8 → ACC10 → INT8 | 정수 양자화 파이프라인 보고서</title>

<!-- Tailwind (utility only) -->
<script src="https://cdn.tailwindcss.com"></script>

<!-- MathJax (LaTeX 수식) -->
<script>
window.MathJax = { tex:{inlineMath:[['$','$'],['\\(','\\)']]}, svg:{fontCache:'global'} };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

<style>
  html,body{font-family:system-ui,-apple-system,"Noto Sans KR",Segoe UI,Roboto,Apple SD Gothic Neo,sans-serif}
  :root{
    --bg:#ffffff; --fg:#0f172a; --muted:#64748b;
    --card:#f8fafc; --line:#e2e8f0; --ink:#0b1324;
    --blue:#2563eb; --aqua:#06b6d4; --vio:#7c3aed; --ok:#10b981; --warn:#f59e0b;
  }
  .card{background:var(--card); border:1px solid var(--line); border-radius:14px}
  .box{background:#fff; border:1.6px solid #cbd5e1; border-radius:12px; padding:.6rem .9rem; min-width:140px; text-align:center}
  .box .t{font-weight:800; color:var(--fg)}
  .box .s{font-size:.72rem; color:#475569}
  .chip{display:inline-block; padding:.18rem .55rem; border-radius:999px; border:1px solid var(--line); background:#fff; font-size:.78rem; color:#334155}
  .arrow{height:2px; width:56px}
  .arrow svg{display:block}
  .note{font-size:.9rem; color:#075985}
  .katex-display{margin:1rem 0 .6rem}
  .mono{font-family:ui-monospace,Consolas,Menlo,monospace}
</style>
</head>
<body class="bg-white text-slate-900">
<main class="max-w-6xl mx-auto px-5 md:px-8 py-10">

  <!-- HEADER -->
  <header class="mb-8">
    <h1 class="text-3xl md:text-4xl font-extrabold tracking-tight">
      정수 양자화 파이프라인 (INT8 → ACC10 → INT8)
    </h1>
    <p class="text-slate-500 mt-2">
      곱셈 후 <b>고정 시프트 S</b>로 10-bit 누산 도메인에 정렬하고, 1st-pass의 <b>a<sub>max</sub></b>를 바탕으로 2nd-pass에서 <b>rq</b>를 적용해 출력 INT8을 헤드룸 <b>H≈120</b>으로 재양자화.
    </p>
  </header>

  <!-- 0. EXEC SUMMARY -->
  <section class="card p-5 md:p-6 mb-8">
    <h2 class="text-xl font-bold mb-2">요약</h2>
    <ul class="list-disc ml-6 text-slate-700 leading-7">
      <li><b>표현</b>: 활성·가중치·출력은 <span class="chip">INT8</span>, 누산은 <span class="chip">10-bit(포화가산)</span>.</li>
      <li><b>스케일</b>: 가중치 per-tensor 대칭 양자화 $s_w=\max|W|/127$, 입력 스케일은 이전 레이어 출력 $s_x$.</li>
      <li><b>연산</b>: $p=x_q\!\cdot\!w_q$ (INT16) → <span class="chip">≫ S</span> → 10-bit clamp → Σ(sat) + <span class="chip">b<sub>acc</sub></span>.</li>
      <li><b>2-pass</b>: 1st-pass에서 $a_{\max}$ 측정, 2nd-pass에서 $rq=H/a_{\max}$ 적용해 $y_q=\mathrm{round}(a\cdot rq)$.</li>
      <li><b>스케일 전파</b>: $s_{acc}=s_x s_w 2^S$, $s_y=s_{acc}/rq$ → 다음 레이어의 $s_x$로 전달.</li>
    </ul>
  </section>

  <!-- 1. GLOSSARY -->
  <section class="grid md:grid-cols-2 gap-5 mb-8">
    <article class="card p-5">
      <h3 class="font-bold text-slate-800">양자화 (Quantization)</h3>
      <p class="text-slate-600 mt-1">실수 텐서를 정수로 표현. 본 구현은 <b>INT8 대칭 per-tensor</b>:</p>
      <p class="mt-2">$$ s_w=\frac{\max|W|}{127},\qquad s_x\ \text{(이전 레이어 출력 스케일)} $$</p>
    </article>
    <article class="card p-5">
      <h3 class="font-bold text-slate-800">재양자화 (Requantization)</h3>
      <p class="text-slate-600 mt-1">누산(ACC10) 결과를 INT8로 다시 스케일. 1st-pass:</p>
      <p class="mt-1">$$ a_{\max}=\max|a|,\qquad rq=\frac{H}{a_{\max}} \ (H\approx120) $$</p>
      <p class="mt-1">2nd-pass: $$ y_q=\mathrm{clip}_{[-128,127]}(\mathrm{round}(a\cdot rq)) $$</p>
    </article>
    <article class="card p-5">
      <h3 class="font-bold text-slate-800">누산 도메인 (ACC10)</h3>
      <p class="text-slate-600 mt-1">INT10 포화 누산 도메인. 스케일:</p>
      <p class="mt-1">$$ \boxed{s_{acc}=s_x\cdot s_w \cdot 2^S} $$</p>
      <p class="mt-1">바이어스 정합: $$ b_{acc}=\mathrm{round}\!\Big(\frac{b_q s_b}{s_{acc}}\Big),\quad s_b=s_w$$</p>
    </article>
    <article class="card p-5">
      <h3 class="font-bold text-slate-800">헤드룸 (H)</h3>
      <p class="text-slate-600 mt-1">출력 INT8이 포화되지 않고 충분한 유효비트를 쓰도록 목표하는 상수(보통 100~127). 본 구현은 <b>120</b>.</p>
      <p class="mt-1">최종 출력 스케일: $$ \boxed{s_y=\frac{s_{acc}}{rq}} $$</p>
    </article>
  </section>

  <!-- 2. MAIN DIAGRAM -->
  <section class="mb-8">
    <div class="flex items-baseline justify-between mb-3">
      <h2 class="text-xl font-bold">메인 다이어그램 — 단일 레이어 내부 데이터 경로</h2>
      <span class="text-slate-500 text-sm">직선 화살표 / 간결 박스</span>
    </div>
    <div class="card p-5 overflow-x-auto">
      <div class="min-w-[980px] flex items-center">
        <div class="box">
          <div class="t">INT8 x<sub>q</sub></div><div class="s">입력 활성</div>
        </div>
        <div class="arrow mx-2">
          <svg viewBox="0 0 64 2" xmlns="http://www.w3.org/2000/svg">
            <line x1="0" y1="1" x2="58" y2="1" stroke="#0f172a" stroke-width="2"/>
            <polygon points="64,1 58,-3 58,5" fill="#0f172a"/>
          </svg>
        </div>
        <div class="box">
          <div class="t">INT8 w<sub>q</sub></div><div class="s">가중치</div>
        </div>
        <div class="arrow mx-2">
          <svg viewBox="0 0 64 2" xmlns="http://www.w3.org/2000/svg">
            <line x1="0" y1="1" x2="58" y2="1" stroke="#0f172a" stroke-width="2"/>
            <polygon points="64,1 58,-3 58,5" fill="#0f172a"/>
          </svg>
        </div>
        <div class="box">
          <div class="t">INT16 p</div><div class="s">p = x<sub>q</sub> · w<sub>q</sub></div>
        </div>
        <div class="arrow mx-2">
          <svg viewBox="0 0 64 2" xmlns="http://www.w3.org/2000/svg">
            <line x1="0" y1="1" x2="58" y2="1" stroke="#0f172a" stroke-width="2"/>
            <polygon points="64,1 58,-3 58,5" fill="#0f172a"/>
          </svg>
        </div>
        <div class="box">
          <div class="t">≫ S</div><div class="s">고정 right-shift</div>
        </div>
        <div class="arrow mx-2">
          <svg viewBox="0 0 64 2" xmlns="http://www.w3.org/2000/svg">
            <line x1="0" y1="1" x2="58" y2="1" stroke="#0f172a" stroke-width="2"/>
            <polygon points="64,1 58,-3 58,5" fill="#0f172a"/>
          </svg>
        </div>
        <div class="box">
          <div class="t">10-bit clamp</div><div class="s">[-512, 511]</div>
        </div>
        <div class="arrow mx-2">
          <svg viewBox="0 0 64 2" xmlns="http://www.w3.org/2000/svg">
            <line x1="0" y1="1" x2="58" y2="1" stroke="#0f172a" stroke-width="2"/>
            <polygon points="64,1 58,-3 58,5" fill="#0f172a"/>
          </svg>
        </div>
        <div class="box">
          <div class="t">ACC(10b) Σ</div><div class="s">포화 누산 + b<sub>acc</sub></div>
        </div>
        <div class="arrow mx-2">
          <svg viewBox="0 0 64 2" xmlns="http://www.w3.org/2000/svg">
            <line x1="0" y1="1" x2="58" y2="1" stroke="#0f172a" stroke-width="2"/>
            <polygon points="64,1 58,-3 58,5" fill="#0f172a"/>
          </svg>
        </div>
        <div class="box">
          <div class="t">rq = H / a<sub>max</sub></div><div class="s">1st측정→2nd적용</div>
        </div>
        <div class="arrow mx-2">
          <svg viewBox="0 0 64 2" xmlns="http://www.w3.org/2000/svg">
            <line x1="0" y1="1" x2="58" y2="1" stroke="#0f172a" stroke-width="2"/>
            <polygon points="64,1 58,-3 58,5" fill="#0f172a"/>
          </svg>
        </div>
        <div class="box">
          <div class="t">INT8 y<sub>q</sub></div><div class="s">다음 레이어 입력</div>
        </div>
      </div>
      <div class="mt-4 space-x-2">
        <span class="chip">s<sub>acc</sub> = s<sub>x</sub> · s<sub>w</sub> · 2<sup>S</sup></span>
        <span class="chip">s<sub>y</sub> = s<sub>acc</sub> / rq</span>
      </div>
    </div>
  </section>

  <!-- 3. FORMULATION (분석적으로) -->
  <section class="grid lg:grid-cols-2 gap-6 mb-10">
    <article class="card p-5">
      <h3 class="font-bold text-lg">① 곱셈 → 시프트 → 클램프</h3>
      <p class="text-slate-600 mt-1">INT8 곱은 INT16로 생성 후, 누산 폭(10-bit)에 안전하게 맞추기 위해 고정 시프트 <span class="chip">S</span>를 적용한다.</p>
      <p class="mt-2">$$ p=x_q\cdot w_q \in \mathbb{Z}_{16},\quad \tilde p=p\gg S,\quad \hat p=\mathrm{clip}_{[-512,511]}(\tilde p) $$</p>
      <p class="text-slate-600 mt-1">시프트가 작을수록 포화 위험↑, 크면 유효비트 낭비↑ → 후단의 동적 <b>rq</b>로 보정.</p>
    </article>
    <article class="card p-5">
      <h3 class="font-bold text-lg">② 누산(ACC10)과 바이어스 정합</h3>
      <p class="text-slate-600 mt-1">바이어스는 가중치 스케일을 공유하므로, 누산 도메인으로 1회 변환해 더한다.</p>
      <p class="mt-2">$$ a=\sum \hat p + b_{acc},\qquad b_{acc}=\mathrm{round}\!\Big(\frac{b_q s_b}{s_{acc}}\Big),\ s_b=s_w $$</p>
      <p class="mt-1">누산 스케일: $$ \boxed{s_{acc}=s_x s_w 2^S} $$</p>
    </article>
    <article class="card p-5">
      <h3 class="font-bold text-lg">③ 2-pass 재양자화</h3>
      <p class="text-slate-600 mt-1">1st-pass에서 $a_{\max}$를 관측해 헤드룸 $H$에 맞춰 스케일을 되살린다.</p>
      <p class="mt-2">$$ rq=\frac{H}{a_{\max}},\qquad y_q=\mathrm{clip}_{[-128,127]}(\mathrm{round}(a\cdot rq)) $$</p>
      <p class="mt-1">출력 스케일: $$ \boxed{s_y=\frac{s_{acc}}{rq}} $$</p>
    </article>
    <article class="card p-5">
      <h3 class="font-bold text-lg">④ 스케일 전파 & 안정성</h3>
      <p class="text-slate-600 mt-1">$s_y$는 다음 레이어의 $s_x$가 된다. 즉, <span class="mono">[스케일 → 누산 → rq → 새 스케일]</span>이 레이어별로 반복된다.</p>
      <ul class="list-disc ml-6 text-slate-700 mt-2 leading-7">
        <li><b>S(고정)</b>: 항 크기 제어(누산 안전성).</li>
        <li><b>rq(동적)</b>: 출력 다이내믹 레인지 복원(정밀도).</li>
        <li><b>Bias</b>: ACC 도메인 정합으로 오프셋 손실 최소화.</li>
      </ul>
    </article>
  </section>

  <!-- 4. NUMERIC EXAMPLE -->
  <section class="card p-5 mb-10">
    <h2 class="text-xl font-bold mb-2">숫자 예시 (단일 레이어)</h2>
    <p class="text-slate-600">가정: $s_x=\tfrac{1}{127}\approx0.007874$, $\max|W|=0.85\Rightarrow s_w=\tfrac{0.85}{127}\approx0.006693$, $S=4$.</p>
    <p class="mt-1">누산 스케일: $s_{acc}=s_x s_w 2^S \approx 8.455\times 10^{-5}$.</p>
    <p class="mt-1">1st-pass: $a_{\max}=350,\ H=120 \Rightarrow rq\approx 0.342857$.</p>
    <p class="mt-1">출력 스케일: $s_y = s_{acc}/rq \approx 2.466\times 10^{-4}$ → 다음 레이어 입력 스케일.</p>
  </section>

  <!-- 5. LAYER FLOW (요약 블록) -->
  <section class="mb-16">
    <h2 class="text-xl font-bold mb-3">레이어 플로우(요약)</h2>
    <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-5">
      <div class="card p-4">
        <div class="font-bold">Conv (k×k, C<sub>in</sub>→C<sub>out</sub>)</div>
        <div class="text-slate-600 text-sm mt-1">INT8×INT8 → (≫S) → ACC10 → 2-pass rq → INT8</div>
      </div>
      <div class="card p-4">
        <div class="font-bold">ReLU</div>
        <div class="text-slate-600 text-sm mt-1">INT8 inplace, 스케일 불변</div>
      </div>
      <div class="card p-4">
        <div class="font-bold">MaxPool 2×2</div>
        <div class="text-slate-600 text-sm mt-1">채널별 최대 선택, 스케일 불변</div>
      </div>
      <div class="card p-4">
        <div class="font-bold">Conv / FC</div>
        <div class="text-slate-600 text-sm mt-1">동일 스킴(ACC10 + 2-pass rq)</div>
      </div>
      <div class="card p-4">
        <div class="font-bold">FC → Softmax</div>
        <div class="text-slate-600 text-sm mt-1">마지막 층은 로짓 INT8 → softmax(실수)로 변환</div>
      </div>
    </div>
  </section>

  <!-- FOOTER -->
  <footer class="text-slate-400 text-sm">
    <p>본 문서는 구현 코드(LeNet 변형)의 <b>정수 양자화·재양자화 설계</b>를 설명하며, 병렬화·파이프라인 제어는 의도적으로 제외했습니다.</p>
  </footer>

</main>
</body>
</html>
